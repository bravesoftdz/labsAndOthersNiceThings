Program.cs:
using System;
namespace Diofant
{
class Program
{
static void Main(string[] args)
{
int n = 3;// кількість невідомих, координат х
int[] koef = new int[] { 7,15,23 };
int res = 113;
GA ga = new GA(n, koef, res);
int genCount = 0;
int[] result = ga.Solve(1000000, ref genCount);
if (result != null)
{
Console.WriteLine("Розв'язок знайдено за {0} iтерацiй",
genCount);
Console.Write("{0}*{1}", result[0], koef[0]);
for (int i = 1; i < n; i++)
{
Console.Write(" + {0}*{1}", result[i], koef[i]);
}
Console.WriteLine(" = {0}", res);
}
else
{
Console.WriteLine("Розв'язку не знайдено");
}
Console.ReadKey();
}
}
}
Рис. 1. Результат розв'язання Діофантового
рівняння генетичним алгоритмом
GA.cs:
using System;
using System.Collections.Generic;
namespace Diofant
{
public class GA
{
private Random r;
private const int CHROMOSOMES_IN_GENERATION = 10;
private const double P_MUTATION = 0.25;
private int n;
private int[] koef;
private int res;
public GA(int n, int[] koef, int res)
{
this.n = n;
this.koef = koef;
this.res = res;
this.r = new Random((int)DateTime.Now.Ticks);
}
private int F(int[] a)
{
int sum = 0;
for (int i = 0; i < n; i++)
{
sum += a[i] * koef[i];
}
return Math.Abs(res - sum);
}
private void GetFirstGeneration(ref List<int[]> generation)
{
for (int i = 0; i < CHROMOSOMES_IN_GENERATION; i++)
{
int[] chromosome = new int[n];
for (int j = 0; j < n; j++)
{
chromosome[j] = r.Next(res) + 1;
}
generation.Add(chromosome);
}
}
private void Crossingover(ref List<int[]> generation)
{
int i;
// Рахуємо пристосованість
double[] fitness = new double[CHROMOSOMES_IN_GENERATION];
for (i = 0; i < CHROMOSOMES_IN_GENERATION; i++)
{
fitness[i] = F(generation[i]);
}
double sum = 0.0;
for (i = 0; i < CHROMOSOMES_IN_GENERATION; i++)
{
fitness[i] = 1.0 / fitness[i];
sum += fitness[i];
}
for (i = 0; i < CHROMOSOMES_IN_GENERATION; i++)
{
fitness[i] /= sum;
}
// Вибираємо батьків
List<int> mother = new List<int>();
List<int> father = new List<int>();
i = 0;
while (mother.Count != CHROMOSOMES_IN_GENERATION)
{
if (r.NextDouble() <= fitness[i]) mother.Add(i);
if (i != CHROMOSOMES_IN_GENERATION - 1) i++; else i = 0;
}
i = 0;
while (father.Count != CHROMOSOMES_IN_GENERATION)
{
if (r.NextDouble() <= fitness[i]) father.Add(i);
if (i != CHROMOSOMES_IN_GENERATION - 1) i++; else i = 0;
}
// Проводимо схрещування
List<int[]> newGeneration = new List<int[]>();
for (int j = 0; j < CHROMOSOMES_IN_GENERATION; j++)
{
int[] c1 = generation[mother[j]];
int[] c2 = generation[father[j]];
int temp;
for (i = 0; i < n / 2; i++)
{
temp = c1[i];
c1[i] = c2[i];
c2[i] = temp;
}
if (r.NextDouble() <= 0.5)
newGeneration.Add(c1);
else
newGeneration.Add(c2);
}
generation = newGeneration;
}
private void Mutation(ref List<int[]> generation)
{
for (int i = 0; i < CHROMOSOMES_IN_GENERATION; i++)
{
for (int j = 0; j < n; j++)
{
if (r.NextDouble() <= P_MUTATION)
{
int randomNumber = r.Next(res) + 1 - res / 2;
int resNumber = generation[i][j] + randomNumber;
if (resNumber <= 0) resNumber = 1;
if (resNumber > res) resNumber = res;
generation[i][j] = resNumber;
}
}
}
}
public int[] Solve(int maxGenerationCount, ref int genCount)
{
List<int[]> generation = new List<int[]>();
GetFirstGeneration(ref generation);
for (int i = 0; i < maxGenerationCount; i++)
{
Crossingover(ref generation);
Mutation(ref generation);
for (int j = 0; j < CHROMOSOMES_IN_GENERATION; j++)
{
if (F(generation[j]) == 0)
{
genCount = i;
return generation[j];
}
}
}
return null;
}
}
}